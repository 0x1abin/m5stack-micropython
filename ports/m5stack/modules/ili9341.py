import timeimport osimport ustructimport gcimport basecolorimport mathfrom machine import Pin, PWM, SPI_COLUMN_SET = const(0x2a)_PAGE_SET = const(0x2b)_RAM_WRITE = const(0x2c)_RAM_READ = const(0x2e)_DISPLAY_ON = const(0x29)_WAKE = const(0x11)_LINE_SET = const(0x37)def color565(r, g, b):    return (r & 0xf8) << 8 | (g & 0xfc) << 3 | b >> 3def size_img(path):    try:        file = open(path, 'rb')        width = ustruct.unpack('>H', file.read(2))[0]        higth = ustruct.unpack('>H', file.read(2))[0]        file.close()        return (width, higth)    except Exception as error:        print('img_size error:', error)        return (-1, -1)class ILI9341:    def __init__(self, spi, cs=Pin(14), dc=Pin(27), rst=Pin(33), backled=PWM(Pin(32)), width=320, height=240,                 bcolor=basecolor.black):        self.width = width        self.height = height        self.spi = spi        self.cs = cs        self.dc = dc        self.rst = rst        self.cs.init(self.cs.OUT, value=1)        self.dc.init(self.dc.OUT, value=0)        self.rst.init(self.rst.OUT, value=0)        self.backled = backled        self.reset()        self.init()        #self.font = font()        #self.font_size = list(self.font.font_lib.keys())        self.backcolor = bcolor        self.clear(self.backcolor)        # self._scroll = 0    ####################################################################################    def brightness(self, brightness):        self.backled.duty(brightness)    def init(self):        for command, data in (                (0xef, b'\x03\x80\x02'),                (0xcf, b'\x00\xc1\x30'),                (0xed, b'\x64\x03\x12\x81'),                (0xe8, b'\x85\x00\x78'),                (0xcb, b'\x39\x2c\x00\x34\x02'),                (0xf7, b'\x20'),                (0xea, b'\x00\x00'),                (0xc0, b'\x23'),  # Power Control 1, VRH[5:0]                (0xc1, b'\x10'),  # Power Control 2, SAP[2:0], BT[3:0]                (0xc5, b'\x3e\x28'),  # VCM Control 1                (0xc7, b'\x86'),  # VCM Control 2                (0x36, b'\x08'),  # Memory Access Control                (0x3a, b'\x55'),  # Pixel Format                (0xb1, b'\x00\x18'),  # FRMCTR1                (0xb6, b'\x08\x82\x27'),  # Display Function Control                (0xf2, b'\x00'),  # 3Gamma Function Disable                (0x26, b'\x01'),  # Gamma Curve Selected                (0xe0, b'\x0f\x31\x2b\x0c\x0e\x08\x4e\xf1\x37\x07\x10\x03\x0e\x09\x00'),  # Set Gamma                (0xe1, b'\x00\x0e\x14\x03\x11\x07\x31\xc1\x48\x08\x0f\x0c\x31\x36\x0f'),  # Set Gamma        ):            self.write(command, data)        self.write(_WAKE)        time.sleep_ms(120)        self.write(_DISPLAY_ON)    def reset(self):        self.rst(0)        time.sleep_ms(50)        self.rst(1)        time.sleep_ms(50)    ####################################################################################    def write(self, command=None, data=None):        if command is not None:            self.dc(0)            self.cs(0)            self.spi.write(bytearray([command]))            self.cs(1)        if data is not None:            self.dc(1)            self.cs(0)            self.spi.write(data)            self.cs(1)    def read(self, command=None, count=None):        self.dc(0)        self.cs(0)        if command is None:            pass        else:            self.spi.write(bytearray([command]))        if count is None:            pass        else:            data = self.spi.read(count)            self.cs(1)            return data        return b''    ################################################################################    def pixel(self, x, y, color=None):  # 在x,y处画一个color颜色的点        if x >= 0 and x < self.width and y >= 0 and y < self.height:            # print("draw a pixel")            self.write(command=0x2a, data=ustruct.pack('>HH', x, x))            self.write(command=0x2b, data=ustruct.pack('>HH', y, y))            if isinstance(color, (tuple, list)):                self.write(command=0x2c, data=ustruct.pack('>H', color565(color[0], color[1], color[2])))            elif isinstance(color, int):                self.write(command=0x2c, data=ustruct.pack('>H', color))            else:                # print('pixel error:The color format is wrong')                return -1        else:            # print('pixel error:pixer out of the LCD')            pass    def hline(self, x, y, width, color=None):  # 水平直线        if abs(width) == 1:            self.pixel(x, y, color)        elif width == 0:            # print('Line width is 0')            return -1        else:            if width > 1:                x1 = x                x2 = x + width - 1                if x2 > self.width - 1:                    x2 = self.width - 1            else:                x2 = x                x1 = x + width + 1                if x1 < 0:                    x1 = 0            if isinstance(color, (tuple, list)):                color_temp = ustruct.pack('>H', color565(color[0], color[1], color[2])) * (x2 - x1 + 1)            elif isinstance(color, int):                color_temp = ustruct.pack('>H', color) * (x2 - x1 + 1)            else:                # print('hline error:The color format is wrong')                return -1            self.write(command=0x2a, data=ustruct.pack('>HH', x1, x2))            self.write(command=0x2b, data=ustruct.pack('>HH', y, y))            self.write(command=0x2c, data=color_temp)    def vline(self, x, y, height, color=None):  # 垂直线        if height == 0:            # print('Line height is 0')            return -1        elif abs(height) == 1:            self.pixel(x, y, color)        else:            if height > 1:                y1 = y                y2 = y1 + height - 1                if y2 > self.height - 1:                    y2 = self.height - 1            else:                y2 = y                y1 = y2 + height + 1                if y1 < 0:                    y1 = 0            if isinstance(color, (tuple, list)):                color_temp = ustruct.pack('>H', color565(color[0], color[1], color[2])) * (y2 - y1 + 1)            elif isinstance(color, int):                color_temp = ustruct.pack('>H', color) * (y2 - y1 + 1)            else:                # print('vline error:The color format is wrong')                return -1            self.write(command=0x2a, data=ustruct.pack('>HH', x, x))            self.write(command=0x2b, data=ustruct.pack('>HH', y1, y2))            self.write(command=0x2c, data=color_temp)    def line(self, x, y, x1, y1, color):  # 画线        '''        if isinstance(color, (tuple, list)):            color = ustruct.pack('>H', color565(color[0], color[1], color[2]))        elif isinstance(color, int):            color = ustruct.pack('>H', color)        else:            return -1        '''        if x == x1:            self.vline(x, y if y <= y1 else y1, abs(y1 - y), color)        elif y == y1:            self.hline(x if x <= x1 else x1, y, abs(x - x1), color)        else:            # keep positive range for x            if x1 < x:                x, x1 = x1, x                y, y1 = y1, y            r = (y1 - y) / (x1 - x)  # r 斜率            # select ratio > 1 for fast drawing (and thin line)            if abs(r) >= 1:                for i in range(x1 - x + 1):                    if (i == 0):  # first always a point                        self.pixel(x + i, math.trunc(y + (r * i)), color)                    else:                        # r may be negative when drawing to wrong way > Fix it when drawing                        self.vline(x + i, math.trunc(y + (r * i) - r) + (0 if r > 0 else math.trunc(r)),                                   abs(math.trunc(r)), color)            else:                # keep positive range for y                if y1 < y:                    x, x1 = x1, x                    y, y1 = y1, y                # invert the ratio (should be close of r = 1/r)                r = (x1 - x) / (y1 - y)                for i in range(y1 - y + 1):                    if (i == 0):  # starting point is always a point                        self.pixel(math.trunc(x + (r * i)), y + i, color)                    else:                        # r may be negative when drawing the wrong way > fix it to draw positive                        self.hline(math.trunc(x + (r * i) - r) + (0 if r > 0 else math.trunc(r)), y + i,                                   abs(math.trunc(r)), color)    def box(self, x, y, width, height, color, is_fill=False, angle=0):  # 方框，is_fill is true 填充        if color is not None:            if (x >= 0 and y >= 0) and (x < self.width and y < self.height):                if width == 1 and height == 1:                    self.pixel(x, y, color)                elif width == 1:                    self.vline(x, y, height)                elif height == 1:                    self.hline(x, y, width)                else:                    if isinstance(color, (tuple, list)):                        color_temp = ustruct.pack('>H', color565(color[0], color[1], color[2]))                    elif isinstance(color, int):                        color_temp = ustruct.pack('>H', color)                    else:                        # print('hline error:The color format is wrong')                        return -1                    if is_fill is True:                        if width > 0 and height > 0:                            x1 = x                            y1 = y                        elif width > 0 and height < 0:                            x1 = x                            y1 = max(y - abs(height) + 1, 0)                        elif width < 0 and height > 0:                            x1 = max(x - abs(width) + 1, 0)                            y1 = y                        else:                            x1 = max(x - abs(width) + 1, 0)                            y1 = max(y - abs(height) + 1, 0)                        self.write(command=0x2a, data=ustruct.pack('>HH', x1, min(x1 + abs(width) - 1, self.width - 1)))                        self.write(command=0x2b,                                   data=ustruct.pack('>HH', y1, min(y1 + abs(height) - 1, self.height - 1)))                        a, b = divmod(abs(width * height), 512)                        self.write(command=0x2c)                        if a > 0:                            temp = color_temp * 512                            for i in range(a):                                self.write(data=temp)                        if b > 0:                            self.write(data=b * color_temp)                    else:                        self.hline(x, y, width, color)                        self.vline(x, y, height, color)                        if width > 0 and height > 0:                            self.vline(min(x + width - 1, self.width - 1), y, height, color)                            self.hline(x, min(y + height - 1, self.height - 1), width, color)                        elif width > 0 and height < 0:                            self.vline(min(x + width - 1, self.width - 1), y, height, color)                            self.hline(x, max(y - abs(height) + 1, 0), width, color)                        elif width < 0 and height > 0:                            self.hline(x, min(y + height - 1, self.height - 1), width, color)                            self.vline(max(x - abs(width) + 1, 0), y, height, color)                        else:                            self.hline(x, max(y - abs(height) + 1, 0), width, color)                            self.vline(max(x - abs(width) + 1, 0), y, height, color)            else:                # print('box error:x,y out of LCD')                pass        else:            # print('box error:The color format is wrong')            return -1    def circle(self, x, y, r, color, is_fill=False):        if isinstance(color, (tuple, list)):            color = ustruct.pack('>H', color565(color[0], color[1], color[2]))        elif isinstance(color, int):            color = ustruct.pack('>H', color)        else:            return -1        a = 0        b = r        while (a <= b):  # // 1/8圆即可            if is_fill:                self.line(x + a, y - b, x + a, y + b, color)                self.line(x - a, y - b, x - a, y + b, color)                self.line(x + b, y + a, x + b, y - a, color)                self.line(x - b, y - a, x - b, y + a, color)            else:                self.pixel(x + a, y - b, color)  # // 0~1                self.pixel(x - a, y - b, color)  # // 0~7                self.pixel(x - a, y + b, color)  # // 4~5                self.pixel(x + a, y + b, color)  # // 4~3                self.pixel(x + b, y + a, color)  # // 2~3                self.pixel(x + b, y - a, color)  # // 2~1                self.pixel(x - b, y - a, color)  # // 6~7                self.pixel(x - b, y + a, color)  # // 6~5            a += 1            num = (a * a + b * b) - r * r            if num > 0:                b -= 1                a -= 1    def clear(self, color):        self.box(0, 0, self.width, self.height, color, is_fill=True)    ################################################################################    def image(self, x, y, name, bcolor=None):        # 在x，y位置显示name图片（name图片在非当前目录时应为路径+名称），bcolor为png图片时背景颜色        try:            file = open(name, 'rb')            width = ustruct.unpack('>H', file.read(2))[0]            higth = ustruct.unpack('>H', file.read(2))[0]            self.write(command=0x2a, data=ustruct.pack('>HH', x, x + width - 1))            self.write(command=0x2b, data=ustruct.pack('>HH', y, y + higth - 1))            self.write(command=0x2c)            #####################################################################            if name[-4:].upper() == 'PNGB':                if bcolor is None:                    background_color = ustruct.pack('>H', self.backcolor)                else:                    background_color = ustruct.pack('>H', bcolor)                a, b = divmod(width * higth * 2, 512)                if a > 0:                    for i in range(a):                        temp = bytearray(file.read(512))                        for n in range(0, 512, 2):                            if temp[n] == 0 and temp[n + 1] == 0:                                temp[n] = background_color[0]                                temp[n + 1] = background_color[1]                        self.write(data=temp)                if b > 0:                    temp = bytearray(file.read(b))                    for n in range(0, b, 2):                        if temp[n] == 0 and temp[n + 1] == 0:                            temp[n] = background_color[0]                            temp[n + 1] = background_color[1]                    self.write(data=temp)                del temp                gc.collect()            #####################################################################            elif name[-4:].upper() == 'JPGB':                a, b = divmod(width * higth * 2, 1024)                if a > 0:                    for i in range(a):                        temp = file.read(1024)                        self.write(data=temp)                if b > 0:                    temp = file.read(b)                    self.write(data=temp)                del temp                gc.collect()            else:                pass        except Exception as error:            print('error:display.image:', error)